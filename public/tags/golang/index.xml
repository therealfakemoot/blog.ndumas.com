<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on code and stuff</title>
    <link>https://ndumas.com/tags/golang/</link>
    <description>Recent content in golang on code and stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Nicholas Dumas 2020</copyright>
    <lastBuildDate>Mon, 08 Jul 2019 10:45:07 -0400</lastBuildDate>
    
	<atom:link href="https://ndumas.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Path of Market: Part 1</title>
      <link>https://ndumas.com/posts/path-of-market1/</link>
      <pubDate>Mon, 08 Jul 2019 10:45:07 -0400</pubDate>
      
      <guid>https://ndumas.com/posts/path-of-market1/</guid>
      <description>Path of Exile is an ARPG similar to Diablo: procedurally generated maps, kill monsters to get loot so you can kill monsters faster. It&amp;rsquo;s pretty fun and offers a really flexible build system that allows for a lot of creativity in how you achieve your goals. Of particular interest is the API exposed by the development team.
Stashes Each character has a set of &amp;ldquo;stashes&amp;rdquo;. These are storage boxes which can be flagged a public.</description>
    </item>
    
    <item>
      <title>Making Noise</title>
      <link>https://ndumas.com/posts/making-noise/</link>
      <pubDate>Thu, 28 Feb 2019 19:37:06 +0000</pubDate>
      
      <guid>https://ndumas.com/posts/making-noise/</guid>
      <description>The Conceit I&amp;rsquo;ve written about Genesis before, but it&amp;rsquo;s got a lot of complexity attached to it, and the roadmap I originally laid out has shifted a bit. For this post I&amp;rsquo;m focusing solely on Phase 1, the generation of geography. This is obviously a fundamental starting point, and it has roadblocked my progress on Genesis for quite some time ( somewhere on the order of 8 years or so ).</description>
    </item>
    
    <item>
      <title>Golang Quantize</title>
      <link>https://ndumas.com/posts/golang-quantize/</link>
      <pubDate>Sun, 22 Apr 2018 17:30:51 +0000</pubDate>
      
      <guid>https://ndumas.com/posts/golang-quantize/</guid>
      <description>The Goal Before going too deep into the implementation details of Genesis, I&amp;rsquo;ll touch on the high level aspect of quantization. Quantization is a technique used to map arbitrary inputs into a well defined output space. This is, practically speaking, a hash function. When the term &amp;lsquo;quantization&amp;rsquo; is used, however, it&amp;rsquo;s typically numeric in nature. Quantization is typically used in audio/image processing to compress inputs for storage or transmission.
Quantizing OpenSimplex My use case is a little less straightforward.</description>
    </item>
    
    <item>
      <title>Genesis Flags</title>
      <link>https://ndumas.com/posts/genesis-flags/</link>
      <pubDate>Sun, 08 Apr 2018 03:44:21 +0000</pubDate>
      
      <guid>https://ndumas.com/posts/genesis-flags/</guid>
      <description>Genesis Genesis is a project I’ve spent a great deal of time thinking about and working on for a while with little progress. I’m recycling my old Github blog post because it still highlights the overall design plan. I’ve since altered the project to use Golang instead of CPython. The change is inspired by a desire/need for improved performance, in my view Golang is the perfect tool to accomplish this goal and is the natural next step in my progression as a developer.</description>
    </item>
    
  </channel>
</rss>